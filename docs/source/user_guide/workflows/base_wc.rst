.. _base_wc:

Fleur base restart workchain
----------------------------

* **Class**: :py:class:`~aiida_fleur.workflows.base_fleur.FleurBaseWorkChain`
* **String to pass to the** :py:func:`~aiida.orm.utils.WorkflowFactory`: ``fleur.base``
* **Workflow type**: Basic
* **Aim**: Implements Base restart workchain for the FleurCalculation
* **Computational demand**: Corresponding a single ``FleurCalculation``
* **Database footprint**: Links to the FleurCalculation output nodes and full provenance
* **File repository footprint**: no addition to the ``CalcJob`` run

.. contents::

Import Example:

.. code-block:: python

    from aiida_fleur.workflows.base_fleur import FleurBaseWorkChain
    #or
    WorkflowFactory('fleur.base')

Description/Purpose
^^^^^^^^^^^^^^^^^^^

This workchain wraps FleurCalculation into BaseRestart workchain. This workchain  automatically
tracks and fixes known technical problems of a CalcJob and, particularly, of a FleurCalculation
that might occur due to instability of machinery. For
now only basic actions are implemented (taken from AiiDA-core package) such as resubmission if
submission failed i.e.

Since there is no FleurCalculation related tactics of the resubmission, we leave this page empty.
For now this workflow can be treated as a pure technical interlayer between higher-level workchains
and FleurCalculation.

.. note::

    This workchain accepts all of the inputs that is needed for the FleurCalculation. It also
    contains all the links of the outputs generated by the FleurCalculation. It most of the cases,
    a user does not feel the difference in the front-end behaviour of FleurCalculation and
    FleurBaseWorkChain.

:py:func:`~aiida_fleur.workflows.base_fleur.FleurBaseWorkChain.check_kpts()` method
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Fixing failed calculations is not the only task of
:py:class:`~aiida_fleur.workflows.base_fleur.FleurBaseWorkChain`. It also implements automatic
parallelisation routine called
:py:func:`~aiida_fleur.workflows.base_fleur.FleurBaseWorkChain.check_kpts()`. The task of this
method is to ensure the perfect k-point parallelisation of the FLEUR code.
It tries to set up the number of nodes and tasks in a way that the total number of used tasks is
a factor of the total number of k-points. Thus a user actually specifies not the actual resources to
be used in a calculation but their maximum possible values.

.. note::

    Before setting the actual resources to the calculation,
    :py:func:`~aiida_fleur.workflows.base_fleur.FleurBaseWorkChain.check_kpts()` can throw an
    exit code if the suggested load of each node is smaller than 60% of what specified by user.
    For example, if user specifies:

    .. code-block:: python

        options = {'resources' : {"num_machines": 4, "num_mpiprocs_per_machine" : 24}

    and :py:func:`~aiida_fleur.workflows.base_fleur.FleurBaseWorkChain.check_kpts()` suggested to
    use 4 ``num_machines`` and 13 ``num_mpiprocs_per_machine`` the exit code will be thrown and
    calculation will not be submitted.

.. _PBS-like: https://aiida.readthedocs.io/projects/aiida-core/en/latest/scheduler/index.html?highlight=schedulers#supported-schedulers

.. warning::

    This method works with `PBS-like`_ schedulers only and if ``num_machines`` and
    ``num_mpiprocs_per_machine`` are specified. Thus it method can be updated/deprecated for
    other schedulers and situations. Please feel free to write an issue on this arguable
    function.
